Nous avons d'abord fait un point sur la manière de relevé alpha2. Cette approche est plus clair puisque toutes les conditions au bord sont maintenant gérées par a. Cela permet surtout de ne pas avoir à résoudre les 2 problèmes pour décomposer les modes propres, ainsi au lieu de résoudre 2M problèmes, où M est le nombre de modes propres, on a plus qu'un problème à résoudre. Le second membre pour le problème spectral est inchangé, car on introduit la composante alpha2 par l'intermédiaire de f_a qui maintenant comporte le terme curl(curl(a)).

J'ai ensuite expliqué le pourquoi le problème aux valeurs propres tel qu'implémenté manquait de stabilité. Cela était dû au fait que la matrice ^b n'était pas définie positive. En effet, pour avoir une base de Zh, il faut enlever une fonction correspondant à un degré de liberté par composante connectée du bord. Le cas où il n'y a qu'une composante connectée est maintenant géré, mais il reste le cas où il y a plusieurs composantes. Cela arrive par exemple dans le cas où il y a un obstacle dans le domaine.
Une fois le correctif mis en place, le problème devient bien plus simple à résoudre, et des méthodes itératives tel que Krylovschur fonctionnent sans problème.

Toutefois, il y a un bug gênant pour récupérer les fonctions propres. En effet, toutes les fonctions sont écrasées par la dernière fonction récupérée. Cela empêche bien entendu tout traitement des modes propres.

Les problèmes à résoudre sont donc :

- Corriger le bug empêchant de récupérer toutes les fonctions propres générées. ( feelpp/feelpp#533 )
- Ecrire proprement le problème pour relever la condition alpha2. ( #24 )
- Implémenter ce problème.
- Implémenter une fonction permettant de supprimer les fonctions de bases superflues. ( #23 )
- Continuer à mettre à jour le rapport.
