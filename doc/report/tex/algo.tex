\chapter{Algorithmes}

\section{Méthode d'Arnoldi}
\label{arnoldi}
L'algorithme d'Arnoldi permet de réduire une matrice carrée $A$ d'ordre $n$ sous la forme d'une matrice de Hessenberg, avec $AV = VH$, où $H$ est une matrice de Hessenberg supérieure et $V$ une matrice orthogonale.\\
Si l'on arrête l'algorithme après $m$ étapes, on obtient une matrice $n\times m$ $V_m$ dont les colonnes sont orthogonalles et une matrice de Hessenberg $H_m$ d'ordre $m$, qui vérifient $AV_m - V_mH_m = fe_m$, où $f$ est le résidu et $e_m$ est le $m$-ième vecteur de la base canonique.\\
Alors $H_m$ est le projeté orthogonal de $A$ sur l'espace $\mathcal{V}$ généré par les vecteurs colonnes de $V_m$. Si $(\lambda_i, y_i)$ est un couple de valeur et de vecteur propres pour $H_m$, alors $(\lambda_i, V_my_i)$ sont appelés respectivement la valeur de Ritz et le vecteur de Ritz, ce sont les approximations de Rayleigh-Ritz des vecteurs et valeurs propres de $A$.\\
En pratique, on utilise $\mathcal{V}= vec<v_1, Av_1, A^2v_1,\dots,A^{m-1}v_1>$, l'espace de Krylov associé à $A$ et au vecteur initial $v_1$.\\

Ce qui donne l'algorithme suivant :
\begin{enumerate}
\item Pour $j=1,2,\dots,m-1$,
\begin{enumerate}
\item $w=Av_j$
\item orthonormalisation par Graam-Schmidt de $w$ par rapport à $v_i$ et obtention des coefficients d'orthonormalisation $h_{i,j}$ $i=1,2,\dots,j$
\item $h_{j+1,j}=||w||_2$
\item $v_j+1=w/h_{j+1,j}$
\end{enumerate}
\item $f=Av_m$
\item orthonormalisation par Graam-Schmidt de $f$ par rapport à $v_i$ et obtention des coefficients d'orthonormalisation $h_{i,m}$ $i=1,2,\dots,m$
\item $\beta=||f||_2$
\end{enumerate}

Toutes les approximations ne sont pas bonnes, pour vérifier on calcul :
\[ ||Ax_i-\lambda_ix_i||_2 = ||AV_my_i-\lambda_iV_my_i||_2 = ||(AV_m-V_mH_m)y_i||_2 = \beta|e_my_i| \]

Lorsque l'on veut un grand nombre de valeurs propres, il faut augmenter la taille de la base $m$, cependant, cela entraine une consomation de ressources importantes. Au lieu d'augmenter $m$, on recommence l'algorithme avec un autre vecteur initial. Il existe plusieurs méthodes pour choisir ce vecteur, on peut par exemple prendre $V_my_i$.\\

La méthode de Krylov-Schur utilisé par SLEPc est une variante de cet algorithme.

%%% Local Variables:
%%% TeX-master: "../report.tex"
%%% eval: (flyspell-mode 1)
%%% ispell-local-dictionary: "french"
%%% End:
