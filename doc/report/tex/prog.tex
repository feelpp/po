\chapter{Programmation}

On programme la résolution de ce problème à l'aide de la bibliothèque Feel++. Pour commencer, on utilise une géomètrie d'un cylindre de rayon 0.05 et de longueur 0.5 orienté dans la direction $z$ (\ref{cylindre}).
\section{FreeFem++}
Dans ce chapitre, on va détailler les différentes méthodes employées par Benjamin pour résoudre le problème dans un cylindre.\\
Tout d'abord, la relation $\rott \mathbf{g} = \grad(\div \mathbf{g}) - \laplace \mathbf{g}$ permet de remplacer, dans $D^1$ où la divergence est nulle, le rotationnel du rotationnel par l'opérateur laplacien.\\
Comme on travail dans le $[H^1]^3$ et non dans $[D^1]^3$, on a besoin de forcer la condition $\div\mathbf{g}=0$, pour cela, on utilise un terme de pression qui joue le rôle d'un multiplicateur de Lagrange. On a donc le problème suivant :
\begin{equation}
\left\{
\begin{aligned}
-\laplace\mathbf{g} - \grad p = \Lambda \mathbf{g}\\
\div \mathbf{g}=0
\end{aligned}
\right.
\end{equation}
En multipliant la première équation par $\bm{\varphi}\in [H^1]^3$ et la seconde par $q\in L^2$, on obtient la formulation faible suivante :
\begin{equation*}
\int_\Omega \overline{\grad\mathbf{g}}:\overline{\grad\bm{\varphi}} + p\div\bm{\varphi} + q\div\mathbf{g} = \Lambda \int_\Omega \mathbf{g}\cdot\bm{\varphi}
\end{equation*}

\subsection{Composante $z$}
\label{freefem1d}
Dans le cylindre, on peut supposer que 
\[
\bm{g}=
\begin{pmatrix}
0\\
0\\
g_3
\end{pmatrix}
\text{ et donc }
\rot\bm{g}=
\begin{pmatrix}
&\delta_y(g_3)\\
&-\delta_x(g_3)\\
&0
\end{pmatrix}
\]
De plus, on sait que $\bm{g}$ ne dépend pas de $z$.\\
Sur l'entrée et la sortie du cylindre, la condition $\bm{g}\cdot \bm{n}=0$ avec $\bm{n}=(0,0,\pm 1)$ conduit à \[g_3 = 0\]
Donc $\bm{g}=0$ sur l'entrée et la sortie.\\

De même sur le tour du cylindre, $\bm{n}=(n_1,n_2,0)$, et la condition $\rot\bm{g}\cdot\bm{n}=0$ donne \[\delta_y(g_3)n_1-\delta_x(g_3)n_3=0\]
Une manière de remplir cette condition est de prendre $\delta_x(g_3)=\delta_y(g_3)=0$, d'où $g_3$ est une constante sur le tour du cylindre.\\
On peut donc prendre $\bm{g}=0$ sur les bords du cylindre.

\subsection{Composantes $(x,y,z)$}
Si l'on ne suppose pas $\bm{g}=(0,0,g_3)$, on a : 
\[
\bm{g}=
\begin{pmatrix}
g_1\\
g_2\\
g_3
\end{pmatrix}
\text{ et }
\rot\bm{g}=
\begin{pmatrix}
\delta_y(g_3)-\delta_z(g_2)\\
\delta_z(g_1)-\delta_x(g_3)\\
\delta_x(g_2)-\delta_y(g_1)
\end{pmatrix}
\]

La condition $\bm{g}\cdot\bm{n}=0$ mène sur l'entrée et la sortie, de la même manière que dans \ref{freefem1d} à $g_3=0$, tandis que sur le tour du cylindre, on peut prendre $g_1=g_2=0$ pour satisfaire cette condition.\\

On peut utiliser la contrainte $\div\bm{g}=0$, qui est continue sur les bords, donc applicables sur le tour du cylindre, pour contraindre $g_3$. Comme sur le tour, $g_1=g_2=0$, on a que $\div\bm{g}=\delta_z(g_3)=0$, donc $g_3$ est une constante sur le tour du cylindre, on peut prendre cette constante égale à 0.\\

La condition $\rot\bm{g}\cdot\bm{n}=0$, sur l'entrée et la sortie se lit $\delta_x(g_2)=\delta_y(g_1)$, toujours de la même façon, prendre $g_1$ constant et $g_2$ constant permet de satisfaire la condition.\\

Comme toutes ces contraintes s'expriment par le fait que $\bm{g}$ doit être une constante, on peut choisir cette constante, par exemple, $\bm{g}=0$.

\subsection{Valeurs analytiques de $\lambda$}

D'après la publication de R. Saks\footnote{\url{http://ejde.math.txstate.edu/conf-proc/13/s1/saks.pdf}}, on a, pour un cylindre de longueur $l$ et de rayon $R$ :
\[
\lambda_\mathcal{K} = \sqrt{\frac{\rho_{k,j}^2}{R^2} + \frac{m^2\pi^2}{l^2}}
\]
où $\mathcal{K}=(k,j,m)$ est un multi-index et $\rho_{k,j}$ représente le j-ième zéro de la k-ième fonction de Bessel.\\
Dans notre cas, $l=0,5$ et $R=0,05$, d'où :
\begin{align*}
\lambda_{(0,1,1)} &\simeq 2352,70 & \lambda_{(0,1,2)} &\simeq 2471,14\\
\lambda_{(0,1,3)} &\simeq 2668,53 & \lambda_{(0,1,4)} &\simeq 2944,88\\
\lambda_{(0,1,5)} &\simeq 3300,19 & \lambda_{(0,1,6)} &\simeq 3734,45\\
\lambda_{(0,1,7)} &\simeq 4247,67 & \lambda_{(0,1,8)} &\simeq 4839,84\\
\lambda_{(0,1,9)} &\simeq 5510,98 & \lambda_{(1,1,1)} &\simeq 5912,25\\
\lambda_{(1,1,2)} &\simeq 6030,68 & \lambda_{(1,1,3)} &\simeq 6228,08\\
\lambda_{(0,1,10)} &\simeq 6261,07 & \lambda_{(1,1,4)} &\simeq 6504,42\\
&\;\;\vdots & &\;\;\vdots
\end{align*}

\section{Problème aux valeurs propres}
\subsection{Valeurs et fonction propres}

On va utiliser une classe \texttt{EigenProblem} acceptant des problèmes de plusieurs dimensions, dans notre cas le problème est de dimension 3.\\
Pour commencer, on va définir l'espace de fonctions, pour cela on va dire au programme que l'on utilise des simplexes, et que la maillage devra être fait de cette manière.\\
Puis comme on veut utiliser chaque composante de la solution pour décrire la normale égale à 0, on va créer une base de fonctions où l'on pourra accéder à chaque composante, chacune sera des fonctions de Lagrange d'ordre 2 scalaire.\\
On utilise enfin la base et le type de maillage pour créer l'espace de fonctions.

\lstinputlisting[linerange={typedef}]{../../src/mode_gen_curl.cpp}

On lit ensuite le nombre de valeurs propres que l'on veut et le nombre de valeurs propres convergées, qui doit être supérieur au premier, dans le fichier de configuration qui doit être nommé de la même manière que l'application. Dans ce fichier doit se trouver aussi le nom du fichier contenant la géographie utilisée, ou le maillage récupérer depuis HyperMesh. On importe cette géographie ou ce maillage avec la fonction \texttt{loadMesh}.

\lstinputlisting[linerange={option,mesh}]{../../src/mode_gen_curl.cpp}

Puis, on a plus qu'à créer un espace de fonction du type précédemment défini, et récupérer deux éléments de cet espace, puis prendre les 3 composantes de ces éléments.

\lstinputlisting[linerange={space}]{../../src/mode_gen_curl.cpp}

Il faut ensuite construire une forme bilinéaire $a$ correspondant à $\int_\Omega curl\ g\cdot curl\ \psi\ dX$. On utilise donc pour cela le fait que $curl\ u = (\partial_y(u_3)-\partial_z(u_2))\vec{i} + (\partial_z(u_1) - \partial_x(u_3))\vec{j} + (\partial_x(u_2)-\partial_y(u_1))\vec{k}$.\\
De plus, on utilise un terme de stabilisation de type $div \times div$. Ce terme ne doit pas jouer de rôle significatif, car la divergence doit tendre vers 0. Il permet seulement d'inverser la matrice A.

\lstinputlisting[linerange={bilinear}]{../../src/mode_gen_curl.cpp}

Puis, on traduit $g\cdot n\big\rvert_{\partial\Omega}=0$ par le fait que $z=0$ sur les deux extrémités du cylindre et que $x=y=0$ sur le tour du cylindre.

\lstinputlisting[linerange={boundary}]{../../src/mode_gen_curl.cpp}

On crée ensuite le second terme correspondant à $\int_\Omega g\cdot\psi\ dX$.

\lstinputlisting[linerange={rhs}]{../../src/mode_gen_curl.cpp}

On peut maintenant résoudre le problème aux valeurs propres. On utilise pour cela la librairie \href{http://www.grycap.upv.es/slepc/}{SLEPc}, qui va utiliser un algorithme de type Krylov-Schur(\ref{arnoldi}) pour trouver \texttt{nev} valeurs propres, en se servant de \texttt{ncv} vecteurs pour la base du sous-espace de Krylov. On crée donc 2 matrices avec les formes bilinéaires précédemment construites, et on indique que l'on cherche les valeurs propres de plus petite magnitute.

\lstinputlisting[linerange={modes}]{../../src/mode_gen_curl.cpp}

Enfin, pour visualiser les résultats, on utilise un élément d'un espace vectoriel qui est le projeté du vecteur formé par les composantes de la solution.

\lstinputlisting[linerange={project}]{../../src/mode_gen_curl.cpp}

Les résultats sont visibles dans le chapitre \ref{resModes}.

\subsection{Décomposition}

\section{Relèvement}

Dans le cas du cylindre, on a $\alpha_1=0$, ce qui conduit à ce que $\rot \mathbf{b}=0$ et donc $\mathbf{a}=\grad\psi^0$.

\subsection{Gradient dans $\HH^1$}
\label{gradh1}

Si l'on veut utiliser le problème (\ref{pbpsi0}) dans $\HH^1$, alors il faut utiliser un multiplicateur de Lagrange pour ajouter une contrainte sur $\psi^0$, par exemple $\int \psi^0 = 0$. Cela se traduit par le changement de formulation variationnelle suivant où l'on cherche $(\psi^0,\lambda)\in \HH^1\times\R$ et où $(\varphi,\nu)$ est la fonction de test :
\[
\int_\Omega\grad \psi^0\grad\varphi + \int_\Omega \psi^0\nu + \int_\Omega \lambda\varphi = \int_{\partial\Omega} \alpha_0\varphi
\]
On va donc créé un espace de fonction produit correspondant à $\HH^1\times\R$.

\lstinputlisting[linerange={space}]{../../src/psi0.cpp}

On ajoute une fonction permettant de rajouter en option le profil d'entrée en fonction du rayon et de la vitesse. Cela correspond à $\alpha_0$.

\lstinputlisting[linerange={option}]{../../src/psi0.cpp}

Une fois les éléments de l'espace créé, on peut définir la forme bilinéaire de la façon suivante :

\lstinputlisting[linerange={bilinear}]{../../src/psi0.cpp}

Ici, $u$ correspond à $\psi^0$ et $v$ à $\varphi$.\\

On veut que ce qui rentre du cylindre par l'entrée, correspondant à la partie du maillage marquée 1, sorte par l'autre bout du cylindre, marqué 2, et que le tour du cylindre, marqué 3, soit imperméable. Ce qui donne la terme de droite suivant :

\lstinputlisting[linerange={rhs}]{../../src/psi0.cpp}

Une fois le problème résolut, on veut projeter le gradient de $\psi^0$ sur $\LL^2$. Pour cela on résout le problème simple $u=\grad\psi^0$.

\lstinputlisting[linerange={gradpsi0}]{../../src/psi0.cpp}

\subsection{Gradient dans $\HH(div)$}

\subsection{Rotationnel}

\section{Problème spectral}

On peut maintenant résoudre le problème (\ref{fvspec}).\\
Cette équation comporte le terme
\[
\sum_i\sum_j c_i\lambda_i c_j(\mathbf{g_i}\times \mathbf{g_j}, \mathbf{g_k})
\]
qui est non linéaire. Ce problème s'écrit donc sous la forme :
\[
F(c) = 0
\]
où $F:\R^M\rightarrow\R^M$, $c=(c_1,\ldots, c_M)$ et :
\begin{align*}
F_k(c) &= \frac{1}{Re} c_k\lambda_k^2 + \sum_i c_i\lambda_i(\mathbf{g_i}\times \mathbf{a}, \mathbf{g_k})\\
&+ \sum_{i,j} c_i\lambda_i c_j (\mathbf{g_i}\times \mathbf{g_j}, \mathbf{g_k}) - (\mathbf{h_a},\mathbf{g_k}) - \frac{1}{Re}\langle \alpha_2, \psi_k \rangle
\end{align*}

On va utiliser une méthode de Newton pour résoudre ce problème, on cherche donc :
\begin{equation}
\label{Newton}
c^{(l+1)} = c^{(l)} - J(c^{(l)})^{-1}F(c^{(l)})\quad l=0,1,\ldots
\end{equation}
où $c^{(0)}$ est une donnée initiale et $J(c)$ est la matrice jacobienne de $F$ en $c$ :
\[
J(c)=
\begin{pmatrix}
\frac{\partial F_1(c)}{\partial c_1} & \ldots & \frac{\partial F_1(c)}{\partial c_M}\\
\vdots & \ddots & \vdots\\
\frac{\partial F_M(c)}{\partial c_1} & \ldots & \frac{\partial F_M(c)}{\partial c_M}
\end{pmatrix}
\]
avec 
\begin{align*}
J(c)_{ki} = \frac{\partial F_k(c)}{\partial c_i} &= \delta_{ki}\lambda_i^2 + \lambda_i(\mathbf{g_i}\times \mathbf{a},\mathbf{g_k})\\
&+ \sum_j\lambda_i c_j (\mathbf{g_i}\times\mathbf{g_j},\mathbf{g_k}) + \sum_j c_j\lambda_j (\mathbf{g_j}\times\mathbf{g_i},\mathbf{g_k})
\end{align*}
Résoudre (\ref{Newton}) est équivalent à résoudre 
\begin{equation}
\label{INewton}
\begin{aligned}
J(c^{(l)})\delta c^{(l)} = -F(c^{(l)})\\
c^{(l+1)}=c{(l)}+\delta c^{(l)}
\end{aligned}
\end{equation}

Toutefois, résoudre exactement (\ref{INewton}) à chaque itération peut être très couteux et peu intéressant, surtout au début lorsque l'on est loin de la solution exacte. On utilise donc une méthode de Newton inexacte pour résoudre cette équation à chaque itération.\\
Cette méthode est elle même une méthode itérative, et la précision de la méthode dépend du nombre d'itération, ainsi, plus on se rapproche de la solution exacte, plus on veut être précis.
\\On se donne donc une suite de nombres positifs $(\eta_l)$, et les itérations continuent jusqu'à ce que :
\[
\frac{||r_l^{(i)}||}{||F(c^{(l)})||} \leq \eta_l<1
\]
où
\[
r_l^{(i)} = J(c^{(l)})\delta c^{(l,i)} + F(c^{(l)})
\]

\section{Pression}


