\chapter{Programmation}

On programme la résolution de ce problème à l'aide de la bibliothèque Feel++. Pour commencer, on utilise une géomètrie d'un cylindre de rayon 0.05 et de longueur 0.5 (\ref{cylindre}).
\section{Problème aux valeurs propres}
\subsection{Valeurs et fonction propres}

On va utiliser une classe \texttt{EigenProblem} acceptant des problèmes de plusieurs dimensions, dans notre cas le problème est de dimension 3.\\
Pour commencer, on va définir l'espace de fonctions, pour cela on va dire au programme que l'on utilise des simplexes, et que la maillage devra être fait de cette manière.\\
Puis comme on veut utiliser chaque composante de la solution pour décrire la normale égale à 0, on va créer une base de fonctions où l'on pourra accéder à chaque composante, chacune sera des fonctions de Lagrange d'ordre 2 scalaire.\\
On utilise enfin la base et le type de maillage pour créer l'espace de fonctions.

\lstinputlisting[linerange={typedef}]{../../src/mode_gen_curl.cpp}

On lit ensuite le nombre de valeurs propres que l'on veut et le nombre de valeurs propres convergées, qui doit être supérieur au premier, dans le fichier de configuration qui doit être nommé de la même manière que l'application. Dans ce fichier doit se trouver aussi le nom du fichier contenant la géographie utilisée, ou le maillage récupérer depuis HyperMesh. On importe cette géographie ou ce maillage avec la fonction \texttt{loadMesh}.

\lstinputlisting[linerange={option,mesh}]{../../src/mode_gen_curl.cpp}

Puis, on a plus qu'à créer un espace de fonction du type précédemment défini, et récupérer deux éléments de cet espace, puis prendre les 3 composantes de ces éléments.

\lstinputlisting[linerange={space}]{../../src/mode_gen_curl.cpp}

Il faut ensuite construire une forme bilinéaire $a$ correspondant à $\int_\Omega curl\ g\cdot curl\ \psi\ dX$. On utilise donc pour cela le fait que $curl\ u = (\partial_y(u_3)-\partial_z(u_2))\vec{i} + (\partial_z(u_1) - \partial_x(u_3))\vec{j} + (\partial_x(u_2)-\partial_y(u_1))\vec{k}$.\\
De plus, on utilise un terme de stabilisation de type $div \times div$. Ce terme ne doit pas jouer de rôle significatif, car la divergence doit tendre vers 0. Il permet seulement d'inverser la matrice A.

\lstinputlisting[linerange={bilinear}]{../../src/mode_gen_curl.cpp}

Puis, on traduit $g\cdot n\big\rvert_{\partial\Omega}=0$ par le fait que $z=0$ sur les deux extrémités du cylindre et que $x=y=0$ sur le tour du cylindre.

\lstinputlisting[linerange={boundary}]{../../src/mode_gen_curl.cpp}

On crée ensuite le second terme correspondant à $\int_\Omega g\cdot\psi\ dX$.

\lstinputlisting[linerange={rhs}]{../../src/mode_gen_curl.cpp}

On peut maintenant résoudre le problème aux valeurs propres. On utilise pour cela la librairie \href{http://www.grycap.upv.es/slepc/}{SLEPc}, qui va utiliser un algorithme de type Krylov-Schur pour trouver \texttt{nev} valeurs propres, en se servant de \texttt{ncv} vecteurs pour la base du sous-espace de Krylov. On crée donc 2 matrices avec les formes bilinéaires précédemment construites, et on indique que l'on cherche les valeurs propres de plus petite magnitute.

\lstinputlisting[linerange={modes}]{../../src/mode_gen_curl.cpp}

Enfin, pour visualiser les résultats, on utilise un élément d'un espace vectoriel qui est le projeté du vecteur formé par les composantes de la solution.

\lstinputlisting[linerange={project}]{../../src/mode_gen_curl.cpp}

Les résultats sont visibles dans le chapitre \ref{resModes}.

\subsection{Décomposition}

\section{Relèvement}

Dans le cas du cylindre, on a $\alpha_1=0$, ce qui conduit à ce que $\rot \mathbf{b}=0$ et donc $\mathbf{a}=\grad\psi^0$.

\subsection{Gradient dans $\HH^1$}
\label{gradh1}

Si l'on veut utiliser le problème (\ref{pbpsi0}) dans $\HH^1$, alors il faut utiliser un multiplicateur de Lagrange pour ajouter une contrainte sur $\psi^0$, par exemple $\int \psi^0 = 0$. Cela se traduit par le changement de formulation variationnelle suivant où l'on cherche $(\psi^0,\lambda)\in \HH^1\times\R$ et où $(\varphi,\nu)$ est la fonction de test :
\[
\int_\Omega\grad \psi^0\grad\varphi + \int_\Omega \psi^0\nu + \int_\Omega \lambda\varphi = \int_{\partial\Omega} \alpha_0\varphi
\]
On va donc créé un espace de fonction produit correspondant à $\HH^1\times\R$.

\lstinputlisting[linerange={space}]{../../src/psi0.cpp}

On ajoute une fonction permettant de rajouter en option le profil d'entrée en fonction du rayon et de la vitesse. Cela correspond à $\alpha_0$.

\lstinputlisting[linerange={option}]{../../src/psi0.cpp}

Une fois les éléments de l'espace créé, on peut définir la forme bilinéaire de la façon suivante :

\lstinputlisting[linerange={bilinear}]{../../src/psi0.cpp}

Ici, $u$ correspond à $\psi^0$ et $v$ à $\varphi$.\\

On veut que ce qui rentre du cylindre par l'entrée, correspondant à la partie du maillage marquée 1, sorte par l'autre bout du cylindre, marqué 2, et que le tour du cylindre, marqué 3, soit imperméable. Ce qui donne la terme de droite suivant :

\lstinputlisting[linerange={rhs}]{../../src/psi0.cpp}

Une fois le problème résolut, on veut projeter le gradient de $\psi^0$ sur $\LL^2$. Pour cela on résout le problème simple $u=\grad\psi^0$.

\lstinputlisting[linerange={gradpsi0}]{../../src/psi0.cpp}

\subsection{Gradient dans $\HH(div)$}

\subsection{Rotationnel}

\section{Problème spectral}

On peut maintenant résoudre le problème (\ref{fvspec}).\\
Cette équation comporte le terme
\[
\sum_i\sum_j c_i\lambda_i c_j(\mathbf{g_i}\times \mathbf{g_j}, \mathbf{g_k})
\]
qui est non linéaire. Ce problème s'écrit donc sous la forme :
\[
F(c) = 0
\]
où $F:\R^M\rightarrow\R^M$, $c=(c_1,\ldots, c_M)$ et :
\begin{align*}
F_k(c) &= \frac{1}{Re} c_k\lambda_k^2 + \sum_i c_i\lambda_i(\mathbf{g_i}\times \mathbf{a}, \mathbf{g_k})\\
&+ \sum_{i,j} c_i\lambda_i c_j (\mathbf{g_i}\times \mathbf{g_j}, \mathbf{g_k}) - (\mathbf{h_a},\mathbf{g_k}) - \frac{1}{Re}\langle \alpha_2, \psi_k \rangle
\end{align*}

On va utiliser une méthode de Newton pour résoudre ce problème, on cherche donc :
\begin{equation}
\label{Newton}
c^{(l+1)} = c^{(l)} - J^{-1}(c^{(l)})F(c^{(l)})\quad l=0,1,\ldots
\end{equation}
où $c^{(0)}$ est une donnée initiale et $J(c)$ est la matrice jacobienne de $F$ en $c$ :
\[
J(c)=
\begin{pmatrix}
\frac{\partial F_1(c)}{\partial c_1} & \ldots & \frac{\partial F_1(c)}{\partial c_M}\\
\vdots & \ddots & \vdots\\
\frac{\partial F_M(c)}{\partial c_1} & \ldots & \frac{\partial F_M(c)}{\partial c_M}
\end{pmatrix}
\]
avec 
\begin{align*}
J(c)_{ki} = \frac{\partial F_k(c)}{\partial c_i} &= \delta_{ki}\lambda_i^2 + \lambda_i(\mathbf{g_i}\times \mathbf{a},\mathbf{g_k})\\
&+ \sum_j\lambda_i c_j (\mathbf{g_i}\times\mathbf{g_j},\mathbf{g_k}) + \sum_j c_j\lambda_j (\mathbf{g_j}\times\mathbf{g_i},\mathbf{g_k})
\end{align*}
Résoudre (\ref{Newton}) est équivalent à résoudre 
\begin{equation}
\label{INewton}
\begin{aligned}
J(c^{(l)})\delta c^{(l)} = -F(c^{(l)})\\
c^{(l+1)}=c{(l)}+\delta c^{(l)}
\end{aligned}
\end{equation}

Toutefois, résoudre exactement (\ref{INewton}) à chaque itération peut être très couteux et peu intéressant, surtout au début lorsque l'on est loin de la solution exacte. On utilise donc une méthode de Newton inexacte pour résoudre cette équation à chaque itération.\\
Cette méthode est elle même une méthode itérative, et la précision de la méthode dépend du nombre d'itération, ainsi, plus on se rapproche de la solution exacte, plus on veut être précis.
\\On se donne donc une suite de nombres positifs $(\eta_l)$, et les itérations continuent jusqu'à ce que :
\[
\frac{||r_l^{(i)}||}{||F(c^{(l)})||} \leq \eta_l<1
\]
où
\[
r_l^{(i)} = J(c^{(l)})\delta c^{(l,i)} + F(c^{(l)})
\]

\section{Pression}


