\section{Maillage}
\subsection{Gmsh}

Pour résoudre ce problème avec Feel++, on commence par recréer le maillage du cylindre avec le logiciel Gmsh pour pouvoir l'utiliser simplement.\\
Pour cela, il faut d'abord créer un cercle, que l'on va ensuite étirer pour faire un cylindre. On construit donc le centre de ce cercle et quatre points permettant de faire quatre arcs de cercle formant un cercle entier, car le logiciel ne permet pas de faire un cercle directement.\\
Chaque point est admet un paramètre définissant la taille du maillage associé.

\lstinputlisting[firstline=3, lastline=13]{../../src/test.geo}

On peut ensuite former une surface avec ces quarts de cercle. On doit déjà former un bord avec ces arcs de cercles et ensuite dire que c'est une surface. Puis on fait de cette surface un élément physique que l'on nommera "entree".

\lstinputlisting[firstline=14, lastline=16]{../../src/test.geo}

On utilise ensuite la commande \texttt{Extrude} pour créer le cylindre à partir de cette surface en le translatant de 0.5 dans la direction z, et en formant 40 couches intermédiaires.\\
En utilisant l'interface graphique, on récupère les numéros des surfaces composant le tour du cylindre et celui de l'autre bout du cylindre. Enfin, il suffit de créer une volume physique pour l'intérieur du cylindre.

\lstinputlisting[firstline=17, lastline=21]{../../src/test.geo}

On peut maintenant utiliser cette géométrie pour le programme en Feel++.

\subsection{HyperMesh}

PlasticOmnium utilise une suite de logiciels, HyperWorks\footnote{\url{http://www.altairhyperworks.com}} pour préparer leurs maillages, faire les calculs et visualiser les résultats. Cette suite, comporte plusieurs logiciels, dont HyperMesh qui permet de faire des maillages avec différents niveaux de précisions quant à la tailles des éléments. Il est important de pouvoir utiliser les maillages issues de HyperMesh. J'ai du donc trouver un moyen de passer des maillages de HyperMesh à ceux de Gmsh.\\
Le format utilisé par Gmsh\footnote{\url{http://geuz.org/gmsh/doc/texinfo/gmsh.html}} est composé de plusieurs parties. Il y a une première partie contenant des informations de formats qui ne change pas.
\begin{verbatim}
$MeshFormat
version-number file-type data-size
$EndMeshFormat
\end{verbatim} 
Puis une partie contenant des informations sur les noeuds organisé de la façon suivante :
\begin{verbatim}
$Nodes
number-of-nodes
node-number x-coord y-coord z-coord
...
$EndNodes
\end{verbatim}
Ensuite, une partie regroupe les informations de tous les éléments, quelque soit leur type.
\begin{verbatim}
$Elements
number-of-elements
elm-number elm-type number-of-tags < tag > ... node-number-list
...
$EndElements
\end{verbatim}
elm-type concerne le type d'élément, triangles à 3 noeuds, tetrahedre avec 4 noeuds, etc. Les tags peuvent détenir plusieurs informations, je n'ai utilisé que les deux obligatoires, l'entité physique et l'entité géométrique.\\
Enfin, une dernière partie optionnelle concerne les entités physiques que l'on utilise ensuite pour les conditions aux bords. 
\begin{verbatim}
$PhysicalNames
number-of-names
physical-dimension physical-number "physical-name"
...
$EndPhysicalNames
\end{verbatim}

Afin de passer d'un maillage de HyperMesh à ce format, j'ai essayé plusieurs solutions, la première est un script à utiliser lorseque l'on a déjà exporter le maillage de HyperMesh, et la seconde est un module à ajouter à HyperMesh permettant d'exporter directement dans le format de Gmsh. 

\subsubsection{Script hmToMsh.sh}

Afin de créer un fichier au format de Gmsh, on commence par écrire la partie fixe du format. 
\lstinputlisting[firstline=38,lastline=40]{../../src/mesh/hmToMsh.sh}

Une fois le maillage prêt dans HyperMesh, on peut l'exporter en différents formats. Celui utilisé par PlasticOmnium produit plusieurs fichiers ainsi qu'un dossier. Dans ce dossier se trouve les fichiers permettant de relire le maillage.\\ 
Un fichier .crd contient les informations pour identifier les noeuds, il contient leur id ainsi que leurs coordonnées. Il se trouve que c'est le même format que celui utilisé par Gmsh. On a donc juste à compter le nombre de lignes du fichier pour connaitre le nombre de noeuds, et ensuite le recopier tel quel.
\lstinputlisting[firstline=43,lastline=47]{../../src/mesh/hmToMsh.sh}

On obtient aussi plusieurs fichiers .ebc qui correspondent aux différentes surfaces que l'on a définit dans HyperMesh, ainsi qu'un fichier .cnn par volume. Comme il y a un élément par ligne dans ces fichiers, il suffit d'additionner leurs nombres de lignes pour connaitre le nombre d'élements.
\lstinputlisting[firstline=61,lastline=64]{../../src/mesh/hmToMsh.sh}

Comme je n'ai travaillé qu'avec des triangles à 3 noeuds et des tétrahedres à 4 noeuds, je n'ai implémenté que ces types d'éléments. Par exemple, pour les triangles, on commence par créer un tableau avec tous les fichiers .ebc triés par le nom de la surface. Puis, pour chaque fichier, on lit chaque ligne que l'on modifie pour retrouver le format de Gmsh. Le format des fichiers .ebc est :
\begin{verbatim}
id-tetra id-triangle id-node1 id-node2 id-node3
\end{verbatim}
où id-tetra est le numéro du tetrahedre auquel le triangle appartient, une information qui nous est inutile. On veut aussi que chaque fichier corresponde à une entité physique et géométrique différente, on incrémente donc un conmpteur à chaque fichier.
\lstinputlisting[firstline=67,lastline=72]{../../src/mesh/hmToMsh.sh}

La partie pour les tetrahedres est très semblables, il n'y a juste pas d'informations inutiles à écarter.\\
Pour les entités physiques, il faut juste recréer un tableau avec les noms de surfaces/volumes et ajouter la dimension et le numéro de l'entité.
\lstinputlisting[firstline=116,lastline=120]{../../src/mesh/hmToMsh.sh}

Ce script fonctionne plutôt bien, il prend environ 3 minutes pour 25 millions de mailles. Cependant, il nécessite d'exporter d'abord dans un format intermédiaire puis de le transcoder dans le format de Gmsh. 

\subsubsection{Module HyperMesh} 

Afin de sauter cette étape j'ai voulu créer un module dans HyperMesh permettant d'exporter directement au bon format. Ce module utilise directement la base de donnée de HyperMesh, c'est ainsi bien plus rapide que le script.\\
De la même manière, on commence par écrire la partie fixe sur le format :
\lstinputlisting[firstline=13,lastline=20]{../../src/mesh/gmsh.tpl}

On utilise donc la commande \texttt{*string("")} pour écrire du texte et \texttt{*field(type, var, taille)} pour écrire une variable. Les autres commandes sont disponibles sur la page d'aide de HyperMesh\footnote{\url{http://www.altairhyperworks.com/hwhelp/Altair/hw12.0/help/hwdref/hwdref.aspx?HyperMesh\_reference\_guide.htm}}.\\
On récupère ensuite les noeuds avec la commande \texttt{*nodes()} et on utilise la fonction \texttt{@count()} pour connaitre le nombre total de noeuds. On peut ensuite utilisé les variables de la base de données pour récupérer les informations.
\lstinputlisting[firstline=22,lastline=40]{../../src/mesh/gmsh.tpl}

De la même manière on utilise la base de donnée pour avoir le nombre d'éléments. En utilisant l'aide, on peut trouver les types des éléments souhaités, triangles et tétrahedre. Le numéro des entités physique et géométrique est le numéro du composant auquel l'élément appartient. Par exemple, les triangles à 3 noeuds sont affectés au nombre 103.
\lstinputlisting[firstline=43,lastline=55]{../../src/mesh/gmsh.tpl}

Pour les entités physiques, j'ai utilisé l'équivalence avec les composants dans HyperMesh. Pour que cela fonctionne, il faut que tous les composants corresponde à ne surface ou un fluide et qu'ils soient tous dans la même assemblée au niveau de la racine (pas de sous-assemblée ).\\
Si le nom de la composante contient le mot ``fluid'', alors c'est un volume, sinon c'est une surface.
\lstinputlisting[firstline=73,lastline=97]{../../src/mesh/gmsh.tpl}
