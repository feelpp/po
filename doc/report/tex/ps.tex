\chapter{Problème spectral}
\section{Cas général}
Intéressons nous maintenant au problème (\ref{fvspec}).\\
Tout d'abord, dans le cylindre, comme $\alpha_1=0$, on a $\bm{a}=\grad\psi^0$ et donc $\rot \bm{a} = 0$. Ce qui amène le terme $\sum_i c_i((\rot \mathbf{a})\times \mathbf{g_i}, \mathbf{g_k})$ à être nul.\\
Cette équation comporte aussi le terme
\[ \sum_i\sum_j c_i\lambda_i c_j(\mathbf{g_i}\times \mathbf{g_j}, \mathbf{g_k}) \]
qui est non linéaire. Ce problème s'écrit donc sous la forme :
\[ F(c) = 0 \]
où $F:\R^M\rightarrow\R^M$, $c=(c_1,\ldots, c_M)$ et :
\begin{align*}
F_k(c) = \frac{1}{Re} c_k\lambda_k^2 &+ \sum_i c_i\lambda_i(\mathbf{g_i}\times \mathbf{a}, \mathbf{g_k})\\
&+ \sum_{i,j} c_i\lambda_i c_j (\mathbf{g_i}\times \mathbf{g_j}, \mathbf{g_k}) - (\mathbf{h_a},\mathbf{g_k})
\end{align*}

On va utiliser une méthode de Newton pour résoudre ce problème, on cherche donc :
\begin{equation}\label{Newton}
c^{(l+1)} = c^{(l)} - J(c^{(l)})^{-1}F(c^{(l)})\quad l=0,1,\ldots
\end{equation}
où $c^{(0)}$ est une donnée initiale et $J(c)$ est la matrice jacobienne de $F$ en $c$ :
\[ J(c)=
\begin{pmatrix}
\frac{\partial F_1(c)}{\partial c_1} & \ldots & \frac{\partial F_1(c)}{\partial c_M}\\
\vdots & \ddots & \vdots\\
\frac{\partial F_M(c)}{\partial c_1} & \ldots & \frac{\partial F_M(c)}{\partial c_M}
\end{pmatrix}\]
avec 
\begin{align*}
J(c)_{ki} = \frac{\partial F_k(c)}{\partial c_i} &= \delta_{ki}\lambda_i^2 + \lambda_i(\mathbf{g_i}\times \mathbf{a},\mathbf{g_k})\\
&+ \sum_j\lambda_i c_j (\mathbf{g_i}\times\mathbf{g_j},\mathbf{g_k}) + \sum_j c_j\lambda_j (\mathbf{g_j}\times\mathbf{g_i},\mathbf{g_k})
\end{align*}
avec $\delta_{ki}$ le symbole de Kronecker.\\

Résoudre (\ref{Newton}) est équivalent à résoudre 
\begin{equation}\label{INewton}
\begin{aligned}
J(c^{(l)})\delta c^{(l)} = -F(c^{(l)})\\
c^{(l+1)}=c{(l)}+\delta c^{(l)}
\end{aligned}
\end{equation}

Toutefois, résoudre exactement (\ref{INewton}) à chaque itération peut être très couteux et peu intéressant, surtout au début lorsque l'on est loin de la solution exacte. On utilise donc une méthode de Newton inexacte pour résoudre cette équation à chaque itération.\\
Cette méthode est elle même une méthode itérative, et la précision de la méthode dépend du nombre d'itération, ainsi, plus on se rapproche de la solution exacte, plus on veut être précis.
\\On se donne donc une suite de nombres positifs $(\eta_l)$, et les itérations continuent jusqu'à ce que :
\[ \frac{||r_l^{(i)}||}{||F(c^{(l)})||} \leq \eta_l<1 \]
où
\[ r_l^{(i)} = J(c^{(l)})\delta c^{(l,i)} + F(c^{(l)}) \]

\subsection{Implémentation}

\lstinputlisting[linerange=ri]{../../src/spectralproblem.hpp}
\lstinputlisting[linerange=lambda]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=riak]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=rijk]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=rfk]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=NSInit]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=NSNewton]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=NSSolve]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=NSNewtonEnd]{../../src/spectralproblem.cpp}

\section{Stokes}
\subsection{Implémentation}

\lstinputlisting[linerange=StokesA]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=StokesB]{../../src/spectralproblem.cpp}
\lstinputlisting[linerange=StokesSolve]{../../src/spectralproblem.cpp}

\subsection{Résultats}

\section{Composante $z$}
\subsection{Implémentation}
\subsection{Résultats}


%%% Local Variables:
%%% TeX-master: "../report.tex"
%%% eval: (flyspell-mode 1)
%%% ispell-local-dictionary: "french"
%%% End:
