\documentclass[a4paper,11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts,amssymb}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{dsfont}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{here}
\usepackage{caption}
\usepackage{subfig}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{fancyvrb}
\newcommand{\N}{{\mathbb{N}}}
\newcommand{\Z}{{\mathbb{Z}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\C}{{\mathbb{C}}}
\newcommand{\LL}{{\mathbb{L}}}

%listins
\lstset{
language=C++,
frame=single,
keywordstyle=\color{magenta}\bfseries,
commentstyle=\color{green}\itshape,
stringstyle=\color{blue},
showstringspaces=false,
breaklines=true,
breakatwhitespace=true,
tabsize=4}

%en tete et pied de page
\geometry{hmargin=2.5cm,vmargin=2.5cm}
\fvset{tabsize=4}
\pagestyle{fancy}
\renewcommand\headrulewidth{1pt}
\renewcommand\footrulewidth{1pt}
\lhead{\leftmark}
\rhead{\rightmark}
\lfoot{Romain HILD\\Stage}
\cfoot{\thepage/\pageref{LastPage}}
\rfoot{Christophe Prud'homme\\Plastic Omnium}
\setlength{\headheight}{15pt}

\graphicspath{{Images/}}

\title{\includegraphics[scale=0.5]{uds.jpg}\\Parallélisation d'un code de calcul aérodynamique instationnaire et validation par comparaison avec des données existantes.}
\author{Romain HILD}
\date{\today\\ \vspace{\fill}\includegraphics[scale=0.5]{po.jpg}\vspace{\fill}}

\begin{document}

\maketitle

\newpage
\tableofcontents

\newpage
\section{Introduction}

Le but de ce projet est la diminution de temps de calcul permettant la simulation des \'ecoulements d'air sur la carrosserie d'une voiture, et plus pr\'ecis\'ement sur des pi\`eces appel\'es "spoilers" ou "vortex generators". Ces pi\`eces sont utilis\'ees pour contr\^oler le flux d'air autour du v\'ehicule, ce qui am\`ene \`a une diminution de l'\'emission de $CO_2$ par la voiture. Cette diminution est tr\`es importante car dans les ann\'ees \`a venir, il y aura beaucoup de normes \`a ce sujets, il est donc important pour les constructeurs automobiles de s'y pr\'eparer d\`es maintenant.\\
Plastic Omnium poss\`ede d\'ej\`a des codes pour des simulations en trois dimensions, cependant ces codes sont utilis\'es sur des mod\`eles de plusieurs millions d'\'el\'ements et donc les calculs prennent plusieurs semaines sur un nombre important de processeurs.\\
L'id\'ee est de choisir un espace dans lequel résoudre les \'equartions de Navier-Stockes qui est g\'en\'er\'e par  les fonction propres de l'op\'erateur rotationel, ainsi une solution pourra s'\'ecrire comme combinaison lin\'eaire de ces fonctions. Ceci, avec les conditions aux limites de l'espace, permet de séparer les termes de temps et d'espace, et ainsi  réutiliser la base de fonctions et ne faire porter les itérations que sur les coefficients temporels.

\section{Problème}
Nous cherchons $(v,p)$, correspondant respectivement à la vitesse et à la pression, solutions de l'équation de Navier-Stokes incompressibles adimensionnalisées dans $Q_T=\Omega\times[0,T]$ un ouvert de $\R^3$ et $\partial\Omega$ sa frontière, avec une condition initiale et des conditions aux limites d'imperméabilité généralisée :
\begin{eqnarray}
\label{depart}
\left\{
\begin{aligned}
&\frac{\partial v}{\partial t} + (curl\  v)\times v + \nabla q -\frac{1}{Re}curl^2\  v-f = 0\\
&div\ v = 0\\
&v\big\rvert_{t=0} = v_0\\
&v\cdot n\big\rvert_{\partial\Omega} = \alpha_0\\
&(curl\  v)\cdot n\big\rvert_{\partial\Omega} = \alpha_1\\
&(curl^2\  v)\cdot n\big\rvert_{\partial\Omega} = \alpha_2
\end{aligned}
\right.
\end{eqnarray}
où $q = \frac{|v|^2}{2}+p$.\\

On définit l'espace
\[
\LL^2_\sigma(\Omega) = \{v \in \LL^2(\Omega) | div\ v = 0\text{ et }v\cdot n\big\rvert_{\partial\Omega} = 0 \}
\]
Alors, on cherche les solutions dans l'espace
\[
D^1(\Omega) = \{v\in W^{1,2}(\Omega) \cup \LL^2(\Omega) | (curl\ v\cdot n)\big\rvert_{\partial\Omega} = 0  \}
\]

Afin de pouvoir résoudre ce problème, on veut se ramener à un problème où $\alpha_0=\alpha_1=0$. On introduit donc une fonction $a$ dans $W^{1,2}(\Omega)$ pour relever le problème tel que :
\begin{eqnarray}
\label{aegal}
\left\{
\begin{aligned}
&a=curl\ b+\nabla\psi_0\\
&div\ a =0\\
&a\cdot n\big\rvert_{\partial\Omega} = \alpha_0\\
&(curl\ a)\cdot n\big\rvert_{\partial\Omega} = \alpha_1
\end{aligned}
\right.
\end{eqnarray}
Comme $div\ a=0$, on obtient l'équation suivante pour $\psi_0\in W^{1,2}(\Omega)$ :
\begin{eqnarray}
\label{psi0}
\left\{
\begin{aligned}
&\Delta\psi_0 = 0\\
&\nabla\psi_0\cdot n\big\rvert_{\partial\Omega}=\alpha_0
\end{aligned}
\right.
\end{eqnarray}

Pour connaitre $b$, il faut résoudre l'équation :
\begin{eqnarray}
\label{curlb}
\left\{
\begin{aligned}
&curl^2\ b = \nabla\psi_1\\
&div\ b = 0\\
&b\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl\ b\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl^2\ b\cdot n\big\rvert_{\partial\Omega} = \alpha_1
\end{aligned}
\right.
\end{eqnarray}
où $\psi_1$ est solution de :
\begin{eqnarray}
\label{psi1}
\left\{
\begin{aligned}
&\Delta\psi_1 = 0\\
&\nabla\psi_1\cdot n\big\rvert_{\partial\Omega} = \alpha_1
\end{aligned}
\right.
\end{eqnarray}

Ce problème ne permet pas de trouver $\psi_1$ mais seulement $\nabla\psi_1$, cela permet toutefois de résoudre l'équation (\ref{curlb}).\\
Une fois $\psi_0$ et $b$ connus, cela permet de retrouver $a$.\\

Ainsi, on peut décomposer $v=a+u$ et le problème est donc de trouver $(u,q)\in Q_T$ tel que :
\begin{eqnarray}
\left\{
\begin{aligned}
&\frac{\partial u}{\partial t} + (curl\  u)\times u + (curl\  u)\times a +(curl\  a)\times u + \nabla q  +\frac{1}{Re}curl^2\  u - h = 0\\
&div\ u = 0\\
&u\big\rvert_{t=0} = v_0 - a(0,\cdot)\\
&u\cdot n\big\rvert_{\partial\Omega} = 0\\
&(curl\  u)\cdot n\big\rvert_{\partial\Omega} = 0\\
&(curl^2\  u)\cdot n\big\rvert_{\partial\Omega} = \alpha_2
\end{aligned}
\right.
\end{eqnarray}
où $h=f-\frac{\partial a}{\partial t} - (curl\  a)\times a$.\\

Comme $u$ appartient à $D^1(\Omega)$, on peut décomposer $u$ sous la forme :
\[
u(t,\cdot) = \sum_{i=1}^{\infty} c_i(t)g_i(\cdot)
\]
On va chercher une valeur approché de $u$ qui se présente sous la forme :
\[
u_M(t,\cdot) = \sum_{i=1}^{M} c_i(t)g_i(\cdot)
\]

Les fonctions $g_i$ forment une base de l'espace $D^1(\Omega) = D(curl_{imperm})$. Cette base est constitué des fonctions propres de l'opérateur rotationel. Elles sont donc solution du problème suivant :
\begin{eqnarray}
\label{curlcurl}
(\lambda_i,g_i)\in\R\times D^1(\Omega)\quad \left\{
\begin{aligned}
&curl^2\  g_i = \lambda_i g_i\\
&g_i\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl\  g_i\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl^2\  g_i\cdot n\big\rvert_{\partial\Omega} = 0
\end{aligned}
\right.
\end{eqnarray}

Toutes fonctions dans $D^1(\Omega)^3$ peut s'écrire $g_i=g_i^0+\nabla\psi_i$ avec $g_i^0\big\rvert_{\partial\Omega} = 0$ et $ \nabla\psi_i\cdot n\big\rvert_{\partial\Omega} = 0$.\\
Ainsi en décomposant dans $(S_6)$, $u$ par sa somme, on obtient le problème suivant où l'on cherche les coefficients $c_i$ :
\begin{eqnarray}
\label{cigi}
\left\{
\begin{aligned}
&\frac{dc_k}{dt}+\sum_{i=1}^M\sum_{j=1}^M c_i\lambda_i c_j r_{ijk} + \sum_{i=1}^M c_i \lambda_i r_{ik}^a + \sum_{i=1}^M c_j r_{jk}^{curl\  a} + \lambda_k^2 c_k = r_k^h - r_k^{\alpha_2}\\
&c_k(0)=c_k^0
\end{aligned}
\right.\quad
1\leq k\leq M
\end{eqnarray}
Où
\[
\begin{aligned}
&r_{ijk} = \langle g_i\times g_j, g_k\rangle_\Omega,\\
&r_{ik}^a=\langle g_i\times a, g_k\rangle_\Omega,\\
&r_{jk}^{curl\  a}=\langle (curl\  a)\times g_j, g_k\rangle\rangle_\Omega,\\
&r_k^h=\langle h,g_k\rangle_\Omega,\\
&r_k^{\alpha_2} = \langle \alpha_2,\psi_k\rangle_{\partial\Omega}.
\end{aligned}
\]

Pour résumer, on doit d'abord générer la base $g_i$ des fonctions propres de l'opérateur curl en résolvant l'équation (\ref{curlcurl}), puis on peut trouver $a$ pour pouvoir décomposer $v$ en $u+a$, pour cela, on résous d'abord les équations (\ref{psi0}) et (\ref{psi1}) afin de pouvoir résoudre (\ref{curlb}). Ce qui permet de trouver $a$ grâce à (\ref{aegal}).\\
Ensuite, on est capable de trouver $u$, pour cela on calcul tous les $r_x^y$ et on résous l'équation (\ref{cigi}) pour $1\leq k\leq M$ afin de connaitre les $c_i$.\\
Cela permet de recomposer $u$ et ensuite $v=u+a$, la solution du problème (\ref{depart}).

\subsection{Problème aux valeurs propres}
\label{eigen}

On s'intéresse ici plus particulièrement au problème (\ref{curlcurl}).
\begin{eqnarray*}
(\lambda_i,g_i)\in\R\times D^1(\Omega)\quad \left\{
\begin{aligned}
&curl^2\  g_i = \lambda_i g_i\\
&g_i\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl\  g_i\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl^2\  g_i\cdot n\big\rvert_{\partial\Omega} = 0
\end{aligned}
\right.
\end{eqnarray*}
On note d'abord que tout élément $\varphi\in D^1(\Omega)$ peut s'écrire de la manière suivante :
\[
\varphi = \varphi_0 + \nabla\phi\text{ et } \varphi\big\rvert_{\partial\Omega} = \nabla\phi
\]

On va maintenant chercher la formulation variationnelle de ce problème.\\
Soit $g\in D^1(\Omega)$ solution de (6), alors pour tout $\varphi\in D^1(\Omega)$ nous avons :
\[
\int_\Omega curl^2\ g\cdot\varphi\ dX = \int_\Omega\lambda g\cdot \varphi\ dX
\]
puis en intégrant par partie :
\[
\int_\Omega curl\ g\cdot curl\ \varphi\ dX + \int_{\partial\Omega} (curl\ g\times \varphi)\cdot n\ d\Gamma = \lambda\int_\Omega g\cdot \varphi\ dX
\]
or sur $\partial\Omega,\quad \varphi\big\rvert_{\partial\Omega}=\nabla\phi$, d'où : 
\[
\int_\Omega curl\ g\cdot curl\ \varphi\ dX + \int_{\partial\Omega} (curl\ g\times \nabla\phi)\cdot n\ d\Gamma = \lambda\int_\Omega g\cdot \varphi\ dX
\]
En utilisant le théorème de flux-divergence aussi appelé théorème de Green-Ostrogradski :
\[
\int_\Omega curl\ g\cdot curl\ \varphi\ dX + \int_\Omega div(curl\ g\times \nabla\phi)\ dX = \lambda\int_\Omega g\cdot \varphi\ dX
\]
En utilisant la formule $div(F\times G) = G\cdot curl\ F - F\cdot curl\ G$, on a :
\[
\int_\Omega curl\ g\cdot curl\ \varphi\ dX + \int_\Omega \nabla\phi\cdot curl^2\ g\ dX -\int_\Omega curl\ g\cdot curl\ \nabla\phi\ dX  = \lambda\int_\Omega g\cdot \varphi\ dX
\]
Comme le rotationel d'un gradient est nul, on a :
\[
\int_\Omega curl\ g\cdot curl\ \varphi\ dX + \int_\Omega \nabla\phi\cdot curl^2\ g\ dX  = \lambda\int_\Omega g\cdot \varphi\ dX
\]
En intégrant le deuxième terme par partie, on obtient : 
\[
\int_\Omega curl\ g\cdot curl\ \varphi\ dX + \int_{\partial\Omega} \phi(curl^2\ g\cdot n)\ d\Gamma - \int_\Omega \phi(div(curl^2\ g))\ dX  = \lambda\int_\Omega g\cdot \varphi\ dX
\]
Comme $curl^2\  g_i\cdot n\big\rvert_{\partial\Omega} = 0$, le deuxième terme s'annule et comme la divergence d'un rotationel est nulle, le troisième terme s'annule aussi, ce qui laisse pour tous $\phi\in D^1(\Omega)$ :
\[
\int_\Omega curl\ g\cdot curl\ \varphi\ dX = \lambda\int_\Omega g\cdot \varphi\ dX
\]

\subsection{Relèvement}

Le problème (\ref{aegal}) sert à retrouver des conditions aux limites pour lesquels on sait résoudre le problème. Pour trouver $a$, il nous faut d'abord résoudre les problèmes (\ref{psi0}-\ref{curlb}-\ref{psi1}).\\

Les problèmes (\ref{psi0}) et (\ref{psi1}) sont semblables, pour les résoudres on uilise la forme variationnelle suivante :
\[
\label{psivar}
-\int_\Omega \nabla\psi\ \nabla\varphi + \int_{\partial\Omega} \alpha\ \varphi = 0
\]

Cela permet de connaitre $\nabla\psi_0$ et $\nabla\psi_1$. On peut donc résoudre le problème (\ref{curlb}) :
\begin{eqnarray}
\left\{
\begin{aligned}
&curl^2\ b = \nabla\psi_1\\
&div\ b = 0\\
&b\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl\ b\cdot n\big\rvert_{\partial\Omega} = 0\\
&curl^2\ b\cdot n\big\rvert_{\partial\Omega} = \alpha_1
\end{aligned}
\right.
\end{eqnarray}

De la même manière que dans le chapitre \ref{eigen}, on peut obtenir la forme variationnelle suivante :
\[
\int_\Omega curl\ b\cdot curl\ \varphi\ dX + \int_{\partial\Omega} \phi(curl^2\ b\cdot n)\ d\Gamma - \int_\Omega \phi(div(curl^2\ b))\ dX  = \int_\Omega \nabla\psi\cdot\varphi dX
\] 

La divergence d'un rotationnel est toujours nul mais comme $curl^2\ b\cdot n = \alpha_1$, on obtient :
\[
\int_\Omega curl\ b\cdot curl\ \varphi\ dX + \int_{\partial\Omega} \phi\alpha_1 d\Gamma = \int_\Omega \nabla\psi\cdot\varphi dX
\]

\section{Maillage}
\subsection{Gmsh}

Pour résoudre ce problème avec Feel++, on commence par recréer le maillage du cylindre avec le logiciel Gmsh pour pouvoir l'utiliser simplement.\\
Pour cela, il faut d'abord créer un cercle, que l'on va ensuite étirer pour faire un cylindre. On construit donc le centre de ce cercle et quatre points permettant de faire quatre arcs de cercle formant un cercle entier, car le logiciel ne permet pas de faire un cercle directement.\\
Chaque point est admet un paramètre définissant la taille du maillage associé.

\lstinputlisting[firstline=3, lastline=13]{../../src/test.geo}

On peut ensuite former une surface avec ces quarts de cercle. On doit déjà former un bord avec ces arcs de cercles et ensuite dire que c'est une surface. Puis on fait de cette surface un élément physique que l'on nommera "entree".

\lstinputlisting[firstline=14, lastline=16]{../../src/test.geo}

On utilise ensuite la commande \texttt{Extrude} pour créer le cylindre à partir de cette surface en le translatant de 0.5 dans la direction z, et en formant 40 couches intermédiaires.\\
En utilisant l'interface graphique, on récupère les numéros des surfaces composant le tour du cylindre et celui de l'autre bout du cylindre. Enfin, il suffit de créer une volume physique pour l'intérieur du cylindre.

\lstinputlisting[firstline=17, lastline=21]{../../src/test.geo}

On peut maintenant utiliser cette géométrie pour le programme en Feel++.

\subsection{HyperMesh}

PlasticOmnium utilise une suite de logiciels, HyperWorks\footnote{\url{http://www.altairhyperworks.com}} pour préparer leurs maillages, faire les calculs et visualiser les résultats. Cette suite, comporte plusieurs logiciels, dont HyperMesh qui permet de faire des maillages avec différents niveaux de précisions quant à la tailles des éléments. Il est important de pouvoir utiliser les maillages issues de HyperMesh. J'ai du donc trouver un moyen de passer des maillages de HyperMesh à ceux de Gmsh.\\
Le format utilisé par Gmsh\footnote{\url{http://geuz.org/gmsh/doc/texinfo/gmsh.html}} est composé de plusieurs parties. Il y a une première partie contenant des informations de formats qui ne change pas.
\begin{verbatim}
$MeshFormat
version-number file-type data-size
$EndMeshFormat
\end{verbatim} 
Puis une partie contenant des informations sur les noeuds organisé de la façon suivante :
\begin{verbatim}
$Nodes
number-of-nodes
node-number x-coord y-coord z-coord
...
$EndNodes
\end{verbatim}
Ensuite, une partie regroupe les informations de tous les éléments, quelque soit leur type.
\begin{verbatim}
$Elements
number-of-elements
elm-number elm-type number-of-tags < tag > ... node-number-list
...
$EndElements
\end{verbatim}
elm-type concerne le type d'élément, triangles à 3 noeuds, tetrahedre avec 4 noeuds, etc. Les tags peuvent détenir plusieurs informations, je n'ai utilisé que les deux obligatoires, l'entité physique et l'entité géométrique.\\
Enfin, une dernière partie optionnelle concerne les entités physiques que l'on utilise ensuite pour les conditions aux bords. 
\begin{verbatim}
$PhysicalNames
number-of-names
physical-dimension physical-number "physical-name"
...
$EndPhysicalNames
\end{verbatim}

Afin de passer d'un maillage de HyperMesh à ce format, j'ai essayé plusieurs solutions, la première est un script à utiliser lorseque l'on a déjà exporter le maillage de HyperMesh, et la seconde est un module à ajouter à HyperMesh permettant d'exporter directement dans le format de Gmsh. 

\subsubsection{Script hmToMsh.sh}

Afin de créer un fichier au format de Gmsh, on commence par écrire la partie fixe du format. 
\lstinputlisting[firstline=38,lastline=40]{../../src/mesh/hmToMsh.sh}

Une fois le maillage prêt dans HyperMesh, on peut l'exporter en différents formats. Celui utilisé par PlasticOmnium produit plusieurs fichiers ainsi qu'un dossier. Dans ce dossier se trouve les fichiers permettant de relire le maillage.\\ 
Un fichier .crd contient les informations pour identifier les noeuds, il contient leur id ainsi que leurs coordonnées. Il se trouve que c'est le même format que celui utilisé par Gmsh. On a donc juste à compter le nombre de lignes du fichier pour connaitre le nombre de noeuds, et ensuite le recopier tel quel.
\lstinputlisting[firstline=43,lastline=47]{../../src/mesh/hmToMsh.sh}

On obtient aussi plusieurs fichiers .ebc qui correspondent aux différentes surfaces que l'on a définit dans HyperMesh, ainsi qu'un fichier .cnn par volume. Comme il y a un élément par ligne dans ces fichiers, il suffit d'additionner leurs nombres de lignes pour connaitre le nombre d'élements.
\lstinputlisting[firstline=61,lastline=64]{../../src/mesh/hmToMsh.sh}

Comme je n'ai travaillé qu'avec des triangles à 3 noeuds et des tétrahedres à 4 noeuds, je n'ai implémenté que ces types d'éléments. Par exemple, pour les triangles, on commence par créer un tableau avec tous les fichiers .ebc triés par le nom de la surface. Puis, pour chaque fichier, on lit chaque ligne que l'on modifie pour retrouver le format de Gmsh. Le format des fichiers .ebc est :
\begin{verbatim}
id-tetra id-triangle id-node1 id-node2 id-node3
\end{verbatim}
où id-tetra est le numéro du tetrahedre auquel le triangle appartient, une information qui nous est inutile. On veut aussi que chaque fichier corresponde à une entité physique et géométrique différente, on incrémente donc un conmpteur à chaque fichier.
\lstinputlisting[firstline=67,lastline=72]{../../src/mesh/hmToMsh.sh}

La partie pour les tetrahedres est très semblables, il n'y a juste pas d'informations inutiles à écarter.\\
Pour les entités physiques, il faut juste recréer un tableau avec les noms de surfaces/volumes et ajouter la dimension et le numéro de l'entité.
\lstinputlisting[firstline=116,lastline=120]{../../src/mesh/hmToMsh.sh}

Ce script fonctionne plutôt bien, il prend environ 3 minutes pour 25 millions de mailles. Cependant, il nécessite d'exporter d'abord dans un format intermédiaire puis de le transcoder dans le format de Gmsh. 

\subsubsection{Module HyperMesh} 

Afin de sauter cette étape j'ai voulu créer un module dans HyperMesh permettant d'exporter directement au bon format. Ce module utilise directement la base de donnée de HyperMesh, c'est ainsi bien plus rapide que le script.\\
De la même manière, on commence par écrire la partie fixe sur le format :
\lstinputlisting[firstline=13,lastline=20]{../../src/mesh/gmsh.tpl}

On utilise donc la commande \texttt{*string("")} pour écrire du texte et \texttt{*field(type, var, taille)} pour écrire une variable. Les autres commandes sont disponibles sur la page d'aide de HyperMesh\footnote{\url{http://www.altairhyperworks.com/hwhelp/Altair/hw12.0/help/hwdref/hwdref.aspx?HyperMesh\_reference\_guide.htm}}.\\
On récupère ensuite les noeuds avec la commande \texttt{*nodes()} et on utilise la fonction \texttt{@count()} pour connaitre le nombre total de noeuds. On peut ensuite utilisé les variables de la base de données pour récupérer les informations.
\lstinputlisting[firstline=22,lastline=40]{../../src/mesh/gmsh.tpl}

De la même manière on utilise la base de donnée pour avoir le nombre d'éléments. En utilisant l'aide, on peut trouver les types des éléments souhaités, triangles et tétrahedre. Le numéro des entités physique et géométrique est le numéro du composant auquel l'élément appartient. Par exemple, les triangles à 3 noeuds sont affectés au nombre 103.
\lstinputlisting[firstline=43,lastline=55]{../../src/mesh/gmsh.tpl}

Pour les entités physiques, j'ai utilisé l'équivalence avec les composants dans HyperMesh. Pour que cela fonctionne, il faut que tous les composants corresponde à ne surface ou un fluide et qu'ils soient tous dans la même assemblée au niveau de la racine (pas de sous-assemblée ).\\
Si le nom de la composante contient le mot ``fluid'', alors c'est un volume, sinon c'est une surface.
\lstinputlisting[firstline=73,lastline=97]{../../src/mesh/gmsh.tpl}

\section{Programmation}
\subsection{FreeFem++}
\subsection{Feel++}

On va utiliser une classe \texttt{EigenProblem} acceptant des problèmes de plusieurs dimensions, dans notre cas le problème est de dimension 3.\\
Pour commencer, on va définir l'espace de fonctions, pour cela on va dire au programme que l'on utilise des simplexes, et que la maillage devra être fait de cette manière.\\
Puis comme on veut utiliser chaque composante de la solution pour décrire la normale égale à 0, on va créer une base de fonctions où l'on pourra accéder à chaque composante, chacune sera des fonctions de Lagrange d'order 2 scalaire.\\
On utilise enfin la base et le type de maillage pour créer l'espace de fonctions.

\lstinputlisting[firstline=33, lastline=36]{../../src/modeGen.cpp}

On lit ensuite le nombre de valeurs propres que l'on veut et le nombre de valeurs propres convergées, qui doit être supérieur au premier, dans le fichier de configuration qui doit être nommé de la même manière que l'application. Dans ce fichier doit se trouver aussi le nom du fichier contenant la géographie utilisée, ou le maillage récupérer depuis HyperMesh. On importe cette géographie ou ce maillage avec la fonction \texttt{loadMesh}.

\lstinputlisting[firstline=70, lastline=79]{../../src/modeGen.cpp}

Puis, on a plus qu'à créer un espace de fonction du type précédemment défini, et récupérer deux éléments de cet espace, puis prendre les 3 composantes de ces éléments.

\lstinputlisting[firstline=88, lastline=96]{../../src/modeGen.cpp}

Il faut ensuite construire une forme bilinéaire $a$ correspondant à $\int_\Omega curl\ g\cdot curl\ \psi\ dX$. On utilise donc pour cela le fait que $curl\ u = (\partial_y(u_3)-\partial_z(u_2))\vec{i} + (\partial_z(u_1) - \partial_x(u_3))\vec{j} + (\partial_x(u_2)-\partial_y(u_1))\vec{k}$.\\
De plus, on utilise un terme de stabilisation de type $div \times div$. Ce terme ne doit pas jouer de rôle significatif, car la divergence doit tendre vers 0. Il permet seulement d'inverser la matrice A.

\lstinputlisting[firstline=99, lastline=104]{../../src/modeGen.cpp}

Puis, on traduit $g\cdot n\big\rvert_{\partial\Omega}=0$ par le fait que $z=0$ sur les deux extrémités du cylindre et que $x=y=0$ sur le tour du cylindre.

\lstinputlisting[firstline=107, lastline=110]{../../src/modeGen.cpp}

On crée ensuite le second terme correspondant à $\int_\Omega g\cdot\psi\ dX$.

\lstinputlisting[firstline=112, lastline=115]{../../src/modeGen.cpp}

On peut maintenant résoudre le problème aux valeurs propres. On utilise pour cela la librairie \href{http://www.grycap.upv.es/slepc/}{SLEPc}. On crée donc 2 matrices avec les formes bilinéaires précédemment construites, et on indique que l'on cherche les plus petites valeurs propres.

\lstinputlisting[firstline=124, lastline=130]{../../src/modeGen.cpp}

Enfin, pour visualiser les résultats, on utilise un élément d'un espace vectoriel qui est le projeté du vecteur formé par les composantes de la solution.

\lstinputlisting[firstline=144, lastline=148]{../../src/modeGen.cpp}

\section{Résultats}
\subsection{Modes}

Pour mémoire, voici les résultats de différents modes obtenus avec freefem++.\\

\begin{figure}[H]
\makebox[\textwidth][c]{
\includegraphics[scale=1]{Exemple_de_modes}}
\end{figure}

On peut voir les mêmes modes obtenus avec Feel++ dans la figure \ref{resultats}.\\

\begin{figure}[H]
	\makebox[\textwidth][c]{
		\subfloat[mode00]{\includegraphics[scale=0.3]{mode00}}\ 
		\subfloat[mode19]{\includegraphics[scale=0.3]{mode19}}
	}\\
	\makebox[\textwidth][c]{
		\subfloat[mode57]{\includegraphics[scale=0.3]{mode57}}\ 
		\subfloat[mode194]{\includegraphics[scale=0.3]{mode194}}
	}
	\caption{composant z des fonctions propres}
	\label{resultats}
\end{figure}

\subsection{Temps de calcul}

Les résultats précédents ont été obtenus sur 10 processeurs avec 200 valeurs propres et 300 valeurs propres convergées en 5536.05 sec, soit environ 1h30.\\

Faute d'installation de freefem++ sur le serveur de l'Irma, je n'ai pas pu effectuer de comparisons directe, mais j'ai lancé plusieurs fois l'application pour comparer le temps de calcul avec un même nombre de processeurs pour différents nombre de modes. Les résultats sont présentés dans la figure \ref{temps_proc}.\\

\begin{figure}[H]
\makebox[\textwidth][c]{
\includegraphics[scale=0.55]{temps_mode}}
\caption{Temps de calcul pour 10 processeurs avec 20, 50, 100, 150 et 200 modes}
\label{temps_proc}
\end{figure}

J'ai ensuite essayé de calculer le même nombre de modes avec un nombre différent de processeurs. Cette fois-ci, les résultats sont plutôt étranges. En effet, moins il y a de processeurs, plus le calcul est rapide, comme le montre la figure \ref{temps_mode}.

\begin{figure}[H]
\makebox[\textwidth][c]{
\includegraphics[scale=0.55]{temps_proc}}
\caption{Temps de calcul pour 50 modes avec 4, 8, 12, 16 et 20 processeurs}
\label{temps_mode}
\end{figure}






\end{document}
